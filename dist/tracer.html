<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Contour Tracer</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { background: #1a1a1a; color: #eee; font-family: monospace; display: flex; flex-direction: column; height: 100vh; }

    #toolbar {
      display: flex; align-items: center; gap: 16px;
      padding: 10px 16px; background: #111; border-bottom: 1px solid #333; flex-shrink: 0;
    }
    #toolbar label { font-size: 13px; color: #aaa; }
    #toolbar input[type=file] { font-size: 12px; color: #ccc; }
    #toolbar input[type=range] { width: 100px; }
    #toolbar span { font-size: 12px; color: #888; }
    button {
      padding: 5px 14px; font-size: 12px; font-family: monospace;
      background: #333; color: #eee; border: 1px solid #555; cursor: pointer; border-radius: 3px;
    }
    button:hover { background: #444; }
    button.danger { border-color: #933; color: #f88; }
    button.danger:hover { background: #411; }
    button.primary { border-color: #474; color: #8f8; }
    button.primary:hover { background: #141; }

    #workspace {
      flex: 1; overflow: auto; display: flex; align-items: flex-start; justify-content: flex-start;
      padding: 20px; gap: 20px;
    }
    #canvas-wrap { position: relative; flex-shrink: 0; }
    #img-bg {
      display: block; max-width: 100%; user-select: none; pointer-events: none;
    }
    #overlay {
      position: absolute; top: 0; left: 0; cursor: crosshair;
    }

    #output-panel {
      flex-shrink: 0; width: 340px; display: flex; flex-direction: column; gap: 10px;
    }
    #output-panel h3 { font-size: 13px; color: #aaa; }
    #stats { font-size: 12px; color: #666; }
    #output {
      flex: 1; background: #111; border: 1px solid #333; padding: 10px;
      font-size: 11px; line-height: 1.5; overflow-y: auto; color: #8fc;
      white-space: pre; border-radius: 4px; min-height: 200px; max-height: 60vh;
    }
    #hint {
      font-size: 12px; color: #666; line-height: 1.6;
    }

    #no-image {
      display: flex; align-items: center; justify-content: center;
      width: 800px; height: 500px; border: 2px dashed #333; border-radius: 6px;
      color: #555; font-size: 14px;
    }
  </style>
</head>
<body>

<div id="toolbar">
  <label>Image: <input type="file" id="file-input" accept="image/*"></label>
  <label>Min dist: <input type="range" id="min-dist" min="2" max="30" value="8"></label>
  <span id="dist-val">8 px</span>
  <label>Scale: <input type="range" id="scale-input" min="20" max="200" value="100"></label>
  <span id="scale-val">100%</span>
  <button class="danger" id="btn-clear">Clear</button>
  <button class="primary" id="btn-copy">Copy to clipboard</button>
</div>

<div id="workspace">
  <div id="canvas-wrap">
    <div id="no-image">← Load an image to start tracing</div>
  </div>

  <div id="output-panel">
    <h3>Traced points → brush.js format</h3>
    <div id="stats">No points yet</div>
    <div id="output">// Hold mouse and drag along the contour.
// Release to capture the segment.
// Multiple drag sessions accumulate.
    </div>
    <div id="hint">
      <b>How to use:</b><br>
      1. Load the hand image above<br>
      2. Hold <b>mouse down</b> and trace the outline<br>
      3. Release to record the segment<br>
      4. Repeat for each part of the contour<br>
      5. Copy the array and paste into index.js
    </div>
  </div>
</div>

<script>
  const fileInput   = document.getElementById('file-input');
  const minDistSlider = document.getElementById('min-dist');
  const distVal     = document.getElementById('dist-val');
  const scaleSlider = document.getElementById('scale-input');
  const scaleVal    = document.getElementById('scale-val');
  const btnClear    = document.getElementById('btn-clear');
  const btnCopy     = document.getElementById('btn-copy');
  const wrap        = document.getElementById('canvas-wrap');
  const noImage     = document.getElementById('no-image');
  const outputEl    = document.getElementById('output');
  const statsEl     = document.getElementById('stats');

  let imgEl = null;
  let overlay = null;
  let ctx = null;

  // Each completed drag becomes its own segment (array of points)
  let segments = [];
  // Points in the current drag
  let currentDrag = [];
  let isDragging = false;
  let lastPt = null;

  // Colors cycled per segment so boundaries are visible
  const SEG_COLORS = ['#ff4400','#00ccff','#ffcc00','#88ff44','#ff88ff'];

  // Target canvas size for output scaling
  const TARGET_W = 2000;
  const TARGET_H = 1000;

  minDistSlider.addEventListener('input', () => {
    distVal.textContent = minDistSlider.value + ' px';
  });

  scaleSlider.addEventListener('input', () => {
    const pct = scaleSlider.value;
    scaleVal.textContent = pct + '%';
    if (imgEl) applyScale(pct / 100);
  });

  function applyScale(factor) {
    const nw = Math.round(imgEl.naturalWidth * factor);
    const nh = Math.round(imgEl.naturalHeight * factor);
    imgEl.style.width  = nw + 'px';
    imgEl.style.height = nh + 'px';
    overlay.width  = nw;
    overlay.height = nh;
    redrawAll();
  }

  fileInput.addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;
    const url = URL.createObjectURL(file);

    // Remove placeholder
    if (noImage) noImage.remove();

    // Create image element if not yet done
    if (!imgEl) {
      imgEl = document.createElement('img');
      imgEl.id = 'img-bg';
      imgEl.draggable = false;
      wrap.appendChild(imgEl);

      overlay = document.createElement('canvas');
      overlay.id = 'overlay';
      wrap.appendChild(overlay);
      ctx = overlay.getContext('2d');

      bindEvents();
    }

    imgEl.onload = () => {
      applyScale(scaleSlider.value / 100);
    };
    imgEl.src = url;

    segments = [];
    currentDrag = [];
    updateOutput();
  });

  function bindEvents() {
    overlay.addEventListener('mousedown', e => {
      isDragging = true;
      currentDrag = [];
      lastPt = null;
      const pt = getPos(e);
      addPoint(pt);
    });

    overlay.addEventListener('mousemove', e => {
      if (!isDragging) return;
      const pt = getPos(e);
      const minDist = parseInt(minDistSlider.value);
      if (!lastPt || dist(lastPt, pt) >= minDist) {
        addPoint(pt);
        drawSegment();
      }
    });

    overlay.addEventListener('mouseup', e => {
      if (!isDragging) return;
      isDragging = false;
      if (currentDrag.length > 0) {
        segments.push([...currentDrag]);
        currentDrag = [];
        updateOutput();
      }
    });

    overlay.addEventListener('mouseleave', e => {
      if (isDragging) {
        isDragging = false;
        if (currentDrag.length > 0) {
          segments.push([...currentDrag]);
          currentDrag = [];
          updateOutput();
        }
      }
    });
  }

  function getPos(e) {
    const r = overlay.getBoundingClientRect();
    return { x: e.clientX - r.left, y: e.clientY - r.top };
  }

  function dist(a, b) {
    return Math.hypot(b.x - a.x, b.y - a.y);
  }

  function addPoint(pt) {
    currentDrag.push(pt);
    lastPt = pt;
  }

  function segColor(i) {
    return SEG_COLORS[i % SEG_COLORS.length];
  }

  function drawSegment() {
    if (currentDrag.length < 2) return;
    const color = segColor(segments.length); // color of the in-progress segment
    const a = currentDrag[currentDrag.length - 2];
    const b = currentDrag[currentDrag.length - 1];
    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(b.x, b.y);
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(b.x, b.y, 2.5, 0, Math.PI * 2);
    ctx.fill();
  }

  function redrawAll() {
    ctx.clearRect(0, 0, overlay.width, overlay.height);
    segments.forEach((seg, i) => {
      if (seg.length === 0) return;
      const color = segColor(i);
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(seg[0].x, seg[0].y);
      for (let j = 1; j < seg.length; j++) ctx.lineTo(seg[j].x, seg[j].y);
      ctx.stroke();
      ctx.fillStyle = color;
      for (const p of seg) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2.5, 0, Math.PI * 2);
        ctx.fill();
      }
    });
  }

  function updateOutput() {
    const totalPts = segments.reduce((s, seg) => s + seg.length, 0);
    statsEl.textContent = `${segments.length} segment(s), ${totalPts} points total`;
    if (segments.length === 0) {
      outputEl.textContent = '// No points yet';
      return;
    }

    // Scale to target canvas size — uniform scale to preserve aspect ratio
    const scale = Math.min(TARGET_W / overlay.width, TARGET_H / overlay.height);

    const blocks = segments.map(seg => {
      const lines = seg.map(p =>
        `  [${Math.round(p.x * scale)}, ${Math.round(p.y * scale)}]`
      ).join(',\n');
      return `const hand = [\n${lines},\n];`;
    });

    outputEl.textContent = blocks.join('\n\n');
  }

  btnClear.addEventListener('click', () => {
    segments = [];
    currentDrag = [];
    if (ctx) ctx.clearRect(0, 0, overlay.width, overlay.height);
    outputEl.textContent = '// Cleared. Start tracing again.';
    statsEl.textContent = 'No points yet';
  });

  btnCopy.addEventListener('click', () => {
    const text = outputEl.textContent;
    navigator.clipboard.writeText(text).then(() => {
      btnCopy.textContent = 'Copied!';
      setTimeout(() => btnCopy.textContent = 'Copy to clipboard', 1500);
    });
  });
</script>
</body>
</html>
